<form id="quiz">
  <fieldset data-q="q1">
    <legend>Q1</legend>
    <label><input type="radio" name="q1" value="yes"> Yes</label>
    <label><input type="radio" name="q1" value="no"> No</label>
    <label><input type="radio" name="q1" value="unknown"> Unknown</label>
    <label><input type="radio" name="q1" value="not_included"> Not included</label>
  </fieldset>

  <fieldset data-q="q2">
    <legend>Q2</legend>
    <label><input type="radio" name="q2" value="yes"> Yes</label>
    <label><input type="radio" name="q2" value="no"> No</label>
    <label><input type="radio" name="q2" value="unknown"> Unknown</label>
  </fieldset>

  <fieldset data-q="q3">
    <legend>Q3</legend>
    <label><input type="radio" name="q3" value="yes"> Yes</label>
    <label><input type="radio" name="q3" value="no"> No</label>
    <label><input type="radio" name="q3" value="unknown"> Unknown</label>
  </fieldset>

  <fieldset data-q="q4">
    <legend>Q4</legend>
    <label><input type="radio" name="q4" value="yes"> Yes</label>
    <label><input type="radio" name="q4" value="no"> No</label>
  </fieldset>
</form>

<script>
  // Order matters: earliest blocker wins
  const questionOrder = ["q1", "q2", "q3", "q4"];

  // Values that disable all *later* questions
  const rules = {
    q1: new Set(["unknown", "not_included"]),
    q2: new Set(["unknown"]),
    q3: new Set(["unknown"]),
    q4: new Set([]),
  };

  const form = document.getElementById("quiz");

  function groupRadios(name) {
    return Array.from(form.querySelectorAll(`input[type="radio"][name="${name}"]`));
  }

  function selectedValue(name) {
    const r = groupRadios(name).find(i => i.checked);
    return r ? r.value : null;
  }

  function setGroupDisabled(name, disabled) {
    const inputs = groupRadios(name);
    inputs.forEach(i => {
      if (disabled) i.checked = false; // clear when disabling
      i.disabled = disabled;
    });
    // Optional: visually disable fieldset
    const fs = form.querySelector(`fieldset[data-q="${name}"]`);
    if (fs) fs.toggleAttribute('disabled', disabled);
  }

  function updateState() {
    // Start by enabling everything
    questionOrder.forEach(q => setGroupDisabled(q, false));

    // Find the earliest question whose selected value blocks following ones
    let earliestBlockIdx = -1;
    for (let i = 0; i < questionOrder.length; i++) {
      const q = questionOrder[i];
      const v = selectedValue(q);
      if (v && rules[q].has(v)) {
        earliestBlockIdx = i;
        break;
      }
    }

    // If a blocker exists, disable all *later* questions
    if (earliestBlockIdx >= 0) {
      for (let j = earliestBlockIdx + 1; j < questionOrder.length; j++) {
        setGroupDisabled(questionOrder[j], true);
      }
    }
  }

  // Wire up listeners
  questionOrder.forEach(q => {
    groupRadios(q).forEach(radio => {
      radio.addEventListener("change", updateState);
    });
  });

  // Initial pass on load
  updateState();
</script>


// grab the button once
const addOtherPPBtn = document.getElementById('addOtherPPBtn');

function updateState() {
  // ... your existing enable-all, compute earliestBlockIdx, disable later groups ...

  // Button rule
  const isBlocked = earliestBlockIdx >= 0;
  const lastEnabledIdx = isBlocked ? earliestBlockIdx : questionOrder.length - 1;
  const allEnabledAnswered = questionOrder
    .slice(0, lastEnabledIdx + 1)
    .every(q => selectedValue(q) !== null);

  const shouldDisable = isBlocked || !allEnabledAnswered;

  if (addOtherPPBtn) {
    // 1) explicit property
    addOtherPPBtn.disabled = shouldDisable;

    // 2) keep HTML attribute in sync (covers cases where someone set it via setAttribute)
    if (shouldDisable) {
      addOtherPPBtn.setAttribute('disabled', '');
      addOtherPPBtn.classList.add('disabled'); // if you use Bootstrap styling
      addOtherPPBtn.setAttribute('aria-disabled', 'true');
    } else {
      addOtherPPBtn.removeAttribute('disabled');
      addOtherPPBtn.classList.remove('disabled');
      addOtherPPBtn.removeAttribute('aria-disabled');

      // 3) if the button lives inside a disabled fieldset, it will STILL be disabled.
      //    Either move the button out, or force the nearest fieldset to enabled:
      const disabledFs = addOtherPPBtn.closest('fieldset[disabled]');
      if (disabledFs) disabledFs.disabled = false; // (or, better: place the button outside that fieldset)
    }
  }
}

function setDisabled(el, disabled) {
  el.disabled = !!disabled;
  if (disabled) el.setAttribute('disabled', '');
  else el.removeAttribute('disabled');
}

  // explicit extras (like a textarea that doesn't share the prefix)
  (extraByGroup[name] || []).forEach(sel => {
    const el = form.querySelector(sel);
    if (el) {
      if (disabled) {
        if (el.tagName === "TEXTAREA") el.value = "";
      }
      setDisabled(el, disabled);
    }
  });

// grab once
const notesTA = document.getElementById('OtherPropertyForm_OtherPersonalPropertyName');

function setDisabled(el, disabled) {
  el.disabled = !!disabled;
  if (disabled) el.setAttribute('disabled','');
  else el.removeAttribute('disabled');
}

function setGroupDisabled(name, disabled) {
  // radios for this group (unchanged)
  Array.from(form.querySelectorAll(`input[type="radio"][name="${name}"]`))
    .forEach(r => { if (disabled) r.checked = false; setDisabled(r, disabled); });

  // text/select/textarea by prefix (keep if you have any)
  const prefix = name.replace(/\.\w+$/, '');
  Array.from(form.querySelectorAll(
    `input[type="text"][name^="${prefix}"], select[name^="${prefix}"], textarea[name^="${prefix}"]`
  )).forEach(el => { if (disabled) { if (el.tagName==='SELECT') el.selectedIndex=-1; else el.value=''; }
                     setDisabled(el, disabled); });

  // ðŸ”¹ one-off textarea by id (no mapping needed)
  if (name === 'OtherPropertyForm.OtherPersonalPropertyName' && notesTA) {
    if (disabled) notesTA.value = '';
    setDisabled(notesTA, disabled);
  }
}


// Put these near your other helpers
function setBoolAttr(el, attr, on) {
  if (on) el.setAttribute(attr, '');
  else el.removeAttribute(attr);
}

function setGroupRequired(name, required) {
  // Radios: set `required` on the FIRST radio only (HTML treats the whole group as required)
  const radios = Array.from(form.querySelectorAll(`input[type="radio"][name="${name}"]`));
  if (radios.length) {
    // Clear required on all, then set on the first one if needed
    radios.forEach(r => setBoolAttr(r, 'required', false));
    setBoolAttr(radios[0], 'required', required);
  }

  // Text / Select / Textarea that belong to the same logical question (by name prefix)
  const prefix = name.replace(/\.\w+$/, '');
  Array.from(form.querySelectorAll(
    `input[type="text"][name^="${prefix}"],
     select[name^="${prefix}"],
     textarea[name^="${prefix}"]`
  )).forEach(el => setBoolAttr(el, 'required', required));
}
